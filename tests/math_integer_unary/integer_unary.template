/*************************************************************************
//
//  SYCL Conformance Test Suite
//
//  Copyright:	(c) 2014 by Codeplay Software LTD. All Rights Reserved.
//
**************************************************************************/

#include "../common/common.h"

#include "./../../util/stl.h"
#include "./../../util/math_helper.h"
#include "./../../util/math_reference.h"

#include "./../../oclmath/reference_math.h"
#include "./../../oclmath/Utility.h"
#include "./../../oclmath/mt19937.h"

namespace wip_integer_unary_$TEST_FUNC$__
{
using namespace sycl_cts;
using namespace cl::sycl;

/** test specifiers
 */
#define TEST_NAME    wip_math_integer_unary_$TEST_FUNC$
#define TEST_TYPE    $TEST_FUNC$
#define ARG_TYPE     uint32_t

/** kernel functor
 */
template <typename Vec>
class cKernel_miu_wip
{
protected:
    typedef accessor<Vec, 1, access::read,  access::global_buffer> t_readAccess;
    typedef accessor<Vec, 1, access::write, access::global_buffer> t_writeAccess;

    t_writeAccess m_o; /* output     */
    t_readAccess  m_x; /* argument X */

public:
    cKernel_miu_wip( t_writeAccess out_, t_readAccess x_ )
        : m_o( out_ )
        , m_x( x_ )
    {
    }

    void operator()( item<1> item )
    {
        int32_t ix = int32_t( item.get_global_linear( ) );
        auto &o = m_o[ix];
        auto  x = m_x[ix];
        o = cl::sycl::TEST_TYPE( x, y );
    }
};

/**
 */
template <typename Base, typename Vec>
class TEST_NAME : public sycl_cts::util::test_base
{
protected:

    /* number of elements in the vector type */
    static const int nVectorElements = sizeof( Vec ) / sizeof( Base );

    /* size of the data buffer to process */
    static const uint32_t nBufferSize = 512;

    /* data buffers */
    util::UNIQUE_PTR<Vec[]> m_xbuf; /* x_arguments */
    util::UNIQUE_PTR<Vec[]> m_obuf; /* output vals */

    /*  */
    MTdata m_randData;

public:
    /** constructor
     */
    TEST_NAME()
        : m_xbuf( nullptr )
        , m_obuf( nullptr )
        , m_randData()
    {
    }

    /** fill the buffer with new values
     */
    void generate( util::logger &, MTdata &rng )
    {
        assert( m_xbuf.get() != nullptr );
        assert( m_obuf.get() != nullptr );

        const int nBytes = sizeof( Vec ) * nBufferSize;
        memset( (uint8_t*)m_obuf.get( ), 0, nBytes );
        math::rand( rng, (uint8_t*)m_xbuf.get(), nBytes );
    }

    /** process an entire buffer
     */
    bool execute( util::logger &log )
    {
        assert( m_obuf.get( ) != nullptr );
        assert( m_xbuf.get( ) != nullptr );

        /* create device selector */
        intel_selector l_selector;

        /* create command queue */
        queue l_queue( l_selector );

        try
        {
            buffer<Vec, 1> xbuf( m_xbuf.get(), nBufferSize );
            buffer<Vec, 1> obuf( m_obuf.get(), nBufferSize );

            /* add command to queue */
            command_group( l_queue, [&]()
            {
                auto xptr = xbuf.template get_access<access::read >();
                auto optr = obuf.template get_access<access::write>();

                /* instantiate the kernel */
                auto kern = cKernel_miu_wip<Vec>( optr, xptr );

                /* execute the kernel */
                parallel_for( nd_range<1>( range<>( nBufferSize ), range<1>( 1 ) ), kern );
            } );
        }
        catch ( cl::sycl::exception e )
        {
            log_exception( log, e );
            FAIL( log, "" );
            return false;
        }

        return true;
    }

    /* verify scalar result
     */
    bool verify( Base result, Base x )
    {
        /* scalar results are 1 on pass
         * and 0 on fail */
        return result == reference::TEST_TYPE( x );
    }

    /* verify the buffer is valid
     */
    bool verify( util::logger &log )
    {
        Vec* x = m_xbuf.get();
        Vec* o = m_obuf.get();
        
        for ( int i = 0; i < nBufferSize; i++ )
        {
            // cast our vector types to an array of their elements
            Base* ex_a = reinterpret_cast<Base*>( x+i );
            Base* eo_a = reinterpret_cast<Base*>( o+i );

            for ( int j = 0; j < nVectorElements; j++ )
            {
                bool pass = false;

                Base ex = ex_a[j];
                Base eo = eo_a[j];

                pass = verify( eo, ex );

                if ( !pass )
                {
                    log.note( "fail at item %d element %d", i, j );
                    log.note( TOSTRING( TEST_TYPE ) "( 0x%llx ) returned 0x%llx", 
                              (uint64_t)ex, (uint64_t)eo );
                    FAIL( log, "" );
                    return false;
                }
            }
        }

        return true;
    }

    /** return information about this test
     *  @param info, test_base::info structure as output
     */
    virtual void get_info( test_base::info &out ) const
    {
        const char *l_name = "invalid name";
#define MAKENAME( X )                          \
    if ( typeid( Vec ) == typeid( X ) )        \
    {                                          \
        l_name = TOSTRING( TEST_NAME ) "_" #X; \
    }
        MAKENAME(  int8_t  );  
        MAKENAME( uint8_t  ); 
        MAKENAME(  int16_t ); 
        MAKENAME( uint16_t ); 
        MAKENAME(  int32_t ); 
        MAKENAME( uint32_t );
        MAKENAME(  int64_t );
        MAKENAME( uint64_t );
        MAKENAME( char2   ); MAKENAME( uchar2   );
        MAKENAME( char3   ); MAKENAME( uchar3   );
        MAKENAME( char4   ); MAKENAME( uchar4   );
        MAKENAME( char8   ); MAKENAME( uchar8   );
        MAKENAME( char16  ); MAKENAME( uchar16  );
        MAKENAME( short2  ); MAKENAME( ushort2  );
        MAKENAME( short3  ); MAKENAME( ushort3  );
        MAKENAME( short4  ); MAKENAME( ushort4  );
        MAKENAME( short8  ); MAKENAME( ushort8  );
        MAKENAME( short16 ); MAKENAME( ushort16 );
        MAKENAME( int2    ); MAKENAME( uint2    );
        MAKENAME( int3    ); MAKENAME( uint3    );
        MAKENAME( int4    ); MAKENAME( uint4    );
        MAKENAME( int8    ); MAKENAME( uint8    );
        MAKENAME( int16   ); MAKENAME( uint16   );
        MAKENAME( long2   ); MAKENAME( ulong2   );
        MAKENAME( long3   ); MAKENAME( ulong3   );
        MAKENAME( long4   ); MAKENAME( ulong4   );
        MAKENAME( long8   ); MAKENAME( ulong8   );
        MAKENAME( long16  ); MAKENAME( ulong16  );

#undef MAKENAME
        set_test_info( out, l_name, TEST_FILE );
    }

    /** clear values required during testing
     *  @return, success
     */
    virtual bool setup( util::logger & )
    {
        m_xbuf.reset( new Vec[nBufferSize] );
        assert( m_xbuf.get() != nullptr );
        memset( m_xbuf.get( ), 0, sizeof(Vec)* nBufferSize );
        
        m_obuf.reset( new Vec[nBufferSize] );
        assert( m_obuf.get() != nullptr );
        memset( m_obuf.get( ), 0, sizeof(Vec)* nBufferSize );

        m_randData = init_genrand( 0 );

        return true;
    }

    /** execute this test
     *  @param log, test transcript logging class
     */
    virtual void run( util::logger &log )
    {
        MTdata rng = init_genrand( 0 );

        generate( log, rng );

        if ( !execute( log ) )
            return;

        if ( !verify( log ) )
            return;
    }

    /** release all test resources
     *
     */
    virtual void cleanup( )
    {
        m_xbuf.reset( nullptr );
        m_obuf.reset( nullptr );
    }
};

/* 1 scalar value */
util::test_proxy<TEST_NAME< uint8_t,  uint8_t>> proxy00;
util::test_proxy<TEST_NAME<uint16_t, uint16_t>> proxy01;
util::test_proxy<TEST_NAME<uint32_t, uint32_t>> proxy02;
util::test_proxy<TEST_NAME<uint64_t, uint64_t>> proxy03;
util::test_proxy<TEST_NAME<  int8_t,   int8_t>> proxy04;
util::test_proxy<TEST_NAME< int16_t,  int16_t>> proxy05;
util::test_proxy<TEST_NAME< int32_t,  int32_t>> proxy06;
util::test_proxy<TEST_NAME< int64_t,  int64_t>> proxy07;

/* 2 element vector */
util::test_proxy<TEST_NAME< uint8_t,  uchar2>> proxy08;
util::test_proxy<TEST_NAME<uint16_t, ushort2>> proxy09;
util::test_proxy<TEST_NAME<uint32_t,   uint2>> proxy0a;
util::test_proxy<TEST_NAME<uint64_t,  ulong2>> proxy0b;
util::test_proxy<TEST_NAME<  int8_t,   char2>> proxy0c;
util::test_proxy<TEST_NAME< int16_t,  short2>> proxy0d;
util::test_proxy<TEST_NAME< int32_t,    int2>> proxy0e;
util::test_proxy<TEST_NAME< int64_t,   long2>> proxy0f;

/* 3 element vector */
util::test_proxy<TEST_NAME< uint8_t,  uchar3>> proxy10;
util::test_proxy<TEST_NAME<uint16_t, ushort3>> proxy11;
util::test_proxy<TEST_NAME<uint32_t,   uint3>> proxy12;
util::test_proxy<TEST_NAME<uint64_t,  ulong3>> proxy13;
util::test_proxy<TEST_NAME<  int8_t,   char3>> proxy14;
util::test_proxy<TEST_NAME< int16_t,  short3>> proxy15;
util::test_proxy<TEST_NAME< int32_t,    int3>> proxy16;
util::test_proxy<TEST_NAME< int64_t,   long3>> proxy17;

/* 4 element vector */
util::test_proxy<TEST_NAME< uint8_t,  uchar4>> proxy18;
util::test_proxy<TEST_NAME<uint16_t, ushort4>> proxy19;
util::test_proxy<TEST_NAME<uint32_t,   uint4>> proxy1a;
util::test_proxy<TEST_NAME<uint64_t,  ulong4>> proxy1b;
util::test_proxy<TEST_NAME<  int8_t,   char4>> proxy1c;
util::test_proxy<TEST_NAME< int16_t,  short4>> proxy1d;
util::test_proxy<TEST_NAME< int32_t,    int4>> proxy1e;
util::test_proxy<TEST_NAME< int64_t,   long4>> proxy1f

/* 8 element vector */
util::test_proxy<TEST_NAME< uint8_t,  uchar8>> proxy20;
util::test_proxy<TEST_NAME<uint16_t, ushort8>> proxy21;
util::test_proxy<TEST_NAME<uint32_t,   uint8>> proxy22;
util::test_proxy<TEST_NAME<uint64_t,  ulong8>> proxy23;
util::test_proxy<TEST_NAME<  int8_t,   char8>> proxy24;
util::test_proxy<TEST_NAME< int16_t,  short8>> proxy25;
util::test_proxy<TEST_NAME< int32_t,    int8>> proxy26;
util::test_proxy<TEST_NAME< int64_t,   long8>> proxy27;

/* 16 element vector */
util::test_proxy<TEST_NAME< uint8_t,  uchar16>> proxy28;
util::test_proxy<TEST_NAME<uint16_t, ushort16>> proxy29;
util::test_proxy<TEST_NAME<uint32_t,   uint16>> proxy2a;
util::test_proxy<TEST_NAME<uint64_t,  ulong16>> proxy2b;
util::test_proxy<TEST_NAME<  int8_t,   char16>> proxy2c;
util::test_proxy<TEST_NAME< int16_t,  short16>> proxy2d;
util::test_proxy<TEST_NAME< int32_t,    int16>> proxy2e;
util::test_proxy<TEST_NAME< int64_t,   long16>> proxy2f; // 64 tests

}; /* wip_math_integer_unary__ */
