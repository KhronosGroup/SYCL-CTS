/*************************************************************************
//
//  SYCL Conformance Test Suite
//
//  Copyright:	(c) 2014 by Codeplay Software LTD. All Rights Reserved.
//
**************************************************************************/

#include <CL/sycl.hpp>

#include "./../../util/stl.h"

#include "./../../oclmath/reference_math.h"
#include "./../../oclmath/Utility.h"

#include "../common/common.h"
#include "../common/math.h"

using namespace cl::sycl;

/** test specifiers
 */
#define TEST_NAME   math_unary_$TEST_FUNC$
#define WIMPY_MODE  1
#define TEST_FUNC   cl::sycl::$TEST_FUNC$
#define REF_FUNC    reference_$TEST_FUNC$
#define MAX_ULPS    $MAX_ULPS$

/**
 */
namespace sycl_cts
{

/** kernel functor
 */
template <typename T>
class cKernel$TEST_FUNC$
{
public:

    typedef accessor<T, 1, access::read_write, access::global_buffer> t_accessor;
    t_accessor access;
    cKernel$TEST_FUNC$( t_accessor p ) : access( p ) { }

    /* the kernel */
    void operator () ( item item )
    {
        access[ item.get_global() ] = 
            TEST_FUNC( access[ item.get_global() ] );
    }

};

/** unary brute force math test
 */
template <typename T>
class TEST_NAME
    : public sycl_cts::util::test_base
{
protected:
    
#if WIMPY_MODE
    /* wimpy mode constants */
    static const uint32_t nStep   = 0x08000000;
    static const uint32_t nScale  = 0x100;
#else
    /* full (brutal) mode constants */
    static const uint32_t nStep   = 0x00080000;
    static const uint32_t nScale  = 0x1;
#endif

    /* size of the data buffer to process */
    static const uint32_t nBufferSize = nStep / nScale;

    /** number of chunks the main buffer should be split into
     *  so that one chunk is processed at a time */
    static const uint32_t nSubBuffers = 16;

    /* data buffer */
    util::UNIQUE_PTR<T> m_buffer;

    /* record the max ULP error */
    float m_max_ulp;
    
public:

    TEST_NAME( )
        : m_buffer( nullptr )
        , m_max_ulp( 0.f )
    {
    }

    /** fill the buffer with new values
     */
    void generate( util::logger & log, const uint32_t j )
    {
        assert( m_buffer.get() != nullptr );

        /* compute new base */
        uint32_t l_base = nStep * j;

        /* fill data buffer */
        for ( uint32_t i = 0; i < nBufferSize; i++ )
        {
            /* compute new value */
            uint32_t x = l_base + i * nScale;

            /* interpret as float */
            float l_val = *( (float*)&x );

            /* expand to kernel data type */
            math::fill( m_buffer.get()[i], l_val );
        }
    }
    
    /** pass the buffer through the kernel
     */
    bool executeChunk(
        util::logger & log       , 
        queue & a_queue          ,
        const uint32_t chunkStart, 
        const uint32_t chunkSize )
    {
        /* check we are always in the buffer */
        assert( (chunkStart + chunkSize) <= nBufferSize );

        try
        {
            buffer< T, 1 > l_buffer( m_buffer.get() + chunkStart, chunkSize );
            
            /* add command to queue */
            command_group( a_queue, [&]()
            {
                auto ptr = 
                    l_buffer.template get_access<access::read_write>( );
        
                /* instantiate the kernel */
                auto kern = cKernel$TEST_FUNC$<T>( ptr );

                /* execute the kernel */
                parallel_for( nd_range<>(range<>(chunkSize), range<>(chunkSize/8)), kern );
                
            });
        }
        catch ( cl::sycl::sycl_error e )
        {
            log_exception( log, e );
            FAIL( log, "" );
            return false;
        }

        return true;
    }

    /** process an entire buffer
     */
    bool execute( util::logger & log, queue &a_queue, const uint32_t j )
    {
        /* number of chunks in this buffer */
        const uint32_t nChunkSize = nBufferSize / nSubBuffers;

        /* step through chunks */
        for ( uint32_t i = 0; i < nBufferSize; i+= nChunkSize )
        {
            /* process this chunk */
            if ( !executeChunk( log, a_queue, i, nChunkSize ) )
                return false;
        }
        
        return true;
    }

    /** verify the buffer is valid
     */
    bool verify( util::logger & log, const uint32_t j )
    {
        /* ULP threshold value */
        const float nULPS = MAX_ULPS;

        /* compute new base */
        unsigned int l_base = nStep * j;

        /* iterate over results buffer */
        for ( unsigned int i = 0; i < nBufferSize; i++ )
        {
            /* compute new X value */
            unsigned int x = l_base + i * nScale;

            /* interpret X value as float */
            float xf = *( (float*) &x );

            /* compare Y value results */
            const auto & l_test      = m_buffer.get()[i];
            const double l_correct   = REF_FUNC( (double) xf );
            const float  l_ulp_error = math::abs_max_ulp_error( l_test, l_correct );

            /* record the max ulps */
            m_max_ulp = fmax( m_max_ulp, l_ulp_error );

            /* check if abs(ULP) exceeds tolerance */
            if (! (l_ulp_error <= nULPS) )
            {
                log.note( "ULP fail @ %f", xf );
                return false;
            }

        }

        return true;
    }
    
    /** return information about this test
     *  @param info, test_base::info structure as output
     */
    virtual void get_info( test_base::info & out ) const
    {
        const char * l_name = "";
#define MAKENAME( X )                              \
        if ( typeid( T ) == typeid( X ) )          \
        { l_name = TOSTRING( TEST_NAME ) "_" #X; }
        MAKENAME( float   );
        MAKENAME( float2  );
        MAKENAME( float3  );
        MAKENAME( float4  );
        MAKENAME( float8  );
        MAKENAME( float16 );
#undef MAKENAME
        set_test_info( out, l_name, TEST_FILE );
    }

    /** clear values required during testing
     *  @return, success
     */
    virtual bool setup( util::logger & log )
    {
        m_max_ulp = 0.f;

        /* construct a new test buffer */
        m_buffer.reset( new T[nBufferSize] );
        assert( m_buffer.get() != nullptr );

        return true;
    }

    /** execute this test
     *  @param log, test transcript logging class
     */
    virtual void run( util::logger & log )
    {
        try
        {
            /* create device selector */
            intel_selector l_selector;

            /* create command queue */
            queue l_queue( l_selector );

            /* find the number of iterations to perform so that we
             * cover the space we want with the step size we are given.
             */
            uint64_t nItts = (1ull << 32) / nStep;

            /*  */
            for ( int j = 0; j < nItts; j++ )
            {
                /* generate a buffer of x values */
                generate( log, j );

                /* convert x values to y values */
                if (! execute( log, l_queue, j ) )
                {
                    FAIL( log, "kernel failed execution" );
                    break;
                }

                /* compare y values to reference y values */
                if (! verify( log, j ) )
                {
                    FAIL( log, "ULP exceeds tolerance" );
                    break;
                }
            }
        
            /* record the max ulps */
            log.note( "max_ulp = %8.2f", m_max_ulp );
        }
        catch ( cl::sycl::sycl_error e )
        {
            FAIL( log, "big fail" );
        }

    }

    /** release all test resources
     *
     */
    virtual void cleanup( util::logger & log )
    {
        /* release the test buffer */
        m_buffer.release( );
    }

};

// register this test with the test_collection
static util::test_proxy<TEST_NAME<float  >> proxy1;
static util::test_proxy<TEST_NAME<float2 >> proxy2;
static util::test_proxy<TEST_NAME<float3 >> proxy3;
static util::test_proxy<TEST_NAME<float4 >> proxy4;
static util::test_proxy<TEST_NAME<float8 >> proxy5;
static util::test_proxy<TEST_NAME<float16>> proxy6;

}; // sycl_cts
