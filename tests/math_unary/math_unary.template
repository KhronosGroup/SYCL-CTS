/*************************************************************************
//
//  SYCL Conformance Test Suite
//
//  Copyright:	(c) 2014 by Codeplay Software LTD. All Rights Reserved.
//
**************************************************************************/

#include <CL/sycl.hpp>

#include "./../../util/stl.h"
#include "./../../util/math_helper.h"

#include "./../../oclmath/reference_math.h"
#include "./../../oclmath/Utility.h"

#include "../common/common.h"

using namespace cl::sycl;

/** test specifiers
 */
#define TEST_NAME math_unary_$TEST_FUNC$
#define WIMPY_MODE 1
#define MAX_ULPS $MAX_ULPS$
#define TEST_FUNC $TEST_FUNC$
#define REF_FUNC reference_$TEST_FUNC$
#define KERNEL_NAME cKernel_$TEST_FUNC$

/**
 */
namespace sycl_cts
{

/** kernel functor
 */
template <typename T>
class KERNEL_NAME
{
public:
    typedef accessor<T, 1, access::read, access::global_buffer> t_read;
    typedef accessor<T, 1, access::write, access::global_buffer> t_write;

    t_read m_in;
    t_write m_out;

    KERNEL_NAME( t_read r_, t_write w_ )
        : m_in( r_ )
        , m_out( w_ )
    {
    }

    void operator()( item item )
    {
        auto in = m_in[item.get_global()];
        auto &out = m_out[item.get_global()];

        out = cl::sycl::TEST_FUNC( in );
    }
};

/** unary brute force math test
 */
template <typename T>
class TEST_NAME : public sycl_cts::util::test_base
{
protected:
#if WIMPY_MODE
    /* wimpy mode constants */
    static const uint32_t nStep = 0x08000000;
    static const uint32_t nScale = 0x100;
#else
    /* full (brutal) mode constants */
    static const uint32_t nStep = 0x00080000;
    static const uint32_t nScale = 0x1;
#endif

    /* size of the data buffer to process */
    static const uint32_t nBufferSize = nStep / nScale;

    /** number of chunks the main buffer should be split into
     *  so that one chunk is processed at a time */
    static const uint32_t nSubBuffers = 16;

    /* data buffer */
    util::UNIQUE_PTR<T> m_input;
    util::UNIQUE_PTR<T> m_output;

    /* record the max ULP error */
    float m_max_ulp;

public:
    TEST_NAME()
        : m_input( nullptr )
        , m_output( nullptr )
        , m_max_ulp( 0.f )
    {
    }

    /** fill the buffer with new values
     */
    void generate( util::logger &log, const uint32_t j )
    {
        assert( m_input.get() != nullptr );
        assert( m_output.get() != nullptr );

        /* compute new base */
        uint32_t l_base = nStep * j;

        /* fill data buffer */
        for ( uint32_t i = 0; i < nBufferSize; i++ )
        {
            /* compute new value */
            uint32_t x = l_base + i * nScale;

            /* interpret as float */
            float l_val = math::int_to_float( x );

            /* expand to kernel data type */
            math::fill( m_input.get()[i], l_val );

            /* clear output buffer */
            math::fill( m_output.get()[i], 0xF8888888 );
        }
    }

    /** pass the buffer through the kernel
     */
    bool executeChunk( util::logger &log, queue &a_queue, const uint32_t chunkStart, const uint32_t chunkSize )
    {
        /* check we are always in the buffer */
        assert( ( chunkStart + chunkSize ) <= nBufferSize );

        try
        {
            buffer<T, 1> l_bufin( m_input.get() + chunkStart, chunkSize );
            buffer<T, 1> l_bufout( m_output.get() + chunkStart, chunkSize );

            /* add command to queue */
            command_group( a_queue, [&]()
                           {
                auto ptrIn = l_bufin.template get_access<access::read>();
                auto ptrOut = l_bufout.template get_access<access::write>();

                /* instantiate the kernel */
                auto kern = KERNEL_NAME<T>( ptrIn, ptrOut );

                /* execute the kernel */
                parallel_for( nd_range<>( range<>( chunkSize ), range<>( chunkSize / 8 ) ), kern );

            } );
        }
        catch ( cl::sycl::sycl_error e )
        {
            log_exception( log, e );
            FAIL( log, "" );
            return false;
        }

        return true;
    }

    /** process an entire buffer
     */
    bool execute( util::logger &log, queue &a_queue, const uint32_t j )
    {
        /* number of chunks in this buffer */
        const uint32_t nChunkSize = nBufferSize / nSubBuffers;

        /* step through chunks */
        for ( uint32_t i = 0; i < nBufferSize; i += nChunkSize )
        {
            /* process this chunk */
            if ( !executeChunk( log, a_queue, i, nChunkSize ) )
                return false;
        }

        return true;
    }

    /** verify the buffer is valid
     */
    bool verify( util::logger &log, const uint32_t j )
    {
        /* ULP threshold value */
        const float nULPS = MAX_ULPS;

        /* compute new base */
        unsigned int l_base = nStep * j;

        /* iterate over results buffer */
        for ( unsigned int i = 0; i < nBufferSize; i++ )
        {
            const auto xv = m_input.get()[i];
            const auto ov = m_output.get()[i];

            /* iterate over vector type */
            for ( int j = 0; j < math::numElements( xv ); j++ )
            {
                float x = math::getElement( xv, j );
                float res = math::getElement( ov, j );

                if ( !verify( log, res, x ) )
                    return false;
            }
        }

        return true;
    }

    /**
     */
    bool verify( util::logger &log, const float res, const float x )
    {
        /* ULP threshold value */
        const float nULPS = MAX_ULPS;

        /* find the reference value */
        const double ref = REF_FUNC( (double)x );

        /* check for correct rounding */
        if ( (float)ref == res )
            return true;

        /* get abs ULP error */
        const float l_ulp_error = fabs( Ulp_Error( res, ref ) );

        /* record the abs max ulps */
        m_max_ulp = fmax( m_max_ulp, l_ulp_error );

        /* check if abs(ULP) exceeds tolerance */
        if ( !( l_ulp_error <= nULPS ) )
        {
            log.note( "ULP fail @ %f", res );
            return false;
        }

        return true;
    }

    /** return information about this test
     *  @param info, test_base::info structure as output
     */
    virtual void get_info( test_base::info &out ) const
    {
        const char *l_name = "";
#define MAKENAME( X )                          \
    if ( typeid( T ) == typeid( X ) )          \
    {                                          \
        l_name = TOSTRING( TEST_NAME ) "_" #X; \
    }
        MAKENAME( float );
        MAKENAME( float2 );
        MAKENAME( float3 );
        MAKENAME( float4 );
        MAKENAME( float8 );
        MAKENAME( float16 );
#undef MAKENAME
        set_test_info( out, l_name, TEST_FILE );
    }

    /** clear values required during testing
     *  @return, success
     */
    virtual bool setup( util::logger &log )
    {
        m_max_ulp = 0.f;

        m_input.reset( new T[nBufferSize] );
        assert( m_input.get() != nullptr );

        m_output.reset( new T[nBufferSize] );
        assert( m_output.get() != nullptr );

        return true;
    }

    /** execute this test
     *  @param log, test transcript logging class
     */
    virtual void run( util::logger &log )
    {
        try
        {
            /* create device selector */
            intel_selector l_selector;

            /* create command queue */
            queue l_queue( l_selector );

            /* find the number of iterations to perform so that we
             * cover the space we want with the step size we are given.
             */
            uint64_t nItts = ( 1ull << 32 ) / nStep;

            /*  */
            for ( int j = 0; j < nItts; j++ )
            {
                /* send progress report */
                log.progress( j, nItts );

                /* generate a buffer of x values */
                generate( log, j );

                /* convert x values to y values */
                if ( !execute( log, l_queue, j ) )
                {
                    FAIL( log, "kernel failed execution" );
                    break;
                }

                /* compare y values to reference y values */
                if ( !verify( log, j ) )
                {
                    FAIL( log, "ULP exceeds tolerance" );
                    break;
                }
            }

            /* send 100% progress report */
            log.progress( nItts, nItts );

            /* record the max ulps */
            log.note( "max_ulp = %8.2f", m_max_ulp );
        }
        catch ( cl::sycl::sycl_error e )
        {
            FAIL( log, "big fail" );
        }
    }

    /** release all test resources
     *
     */
    virtual void cleanup( util::logger &log )
    {
        m_input.reset( nullptr );
        m_output.reset( nullptr );
    }
};

/* register this test with the test_collection */
static util::test_proxy<TEST_NAME<float  >> proxy1;
static util::test_proxy<TEST_NAME<float2 >> proxy2;
static util::test_proxy<TEST_NAME<float3 >> proxy3;
static util::test_proxy<TEST_NAME<float4 >> proxy4;
static util::test_proxy<TEST_NAME<float8 >> proxy5;
static util::test_proxy<TEST_NAME<float16>> proxy6;

};  // sycl_cts
