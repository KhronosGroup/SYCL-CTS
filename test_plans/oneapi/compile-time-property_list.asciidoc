:sectnums:
:xrefstyle: short

= Test plan for compile-time property_list

This is a test plan for the APIs described in
https://github.com/intel/llvm/blob/sycl/sycl/doc/extensions/PropertyList/SYCL_EXT_ONEAPI_property_list.asciidoc[SYCL_EXT_ONEAPI_property_list.asciidoc]


== Testing scope

=== Device coverage

All of the tests described below are performed only on the default device that
is selected on the CTS command line.

=== Feature test macro

All of the tests should use `#ifdef SYCL_EXT_ONEAPI_PROPERTY_LIST` so they can be skipped
if feature is not supported.

== Tests

Tests are using compile-time properties from extension SYCL_EXT_ONEAPI_DEVICE_GLOBAL,
because of it test should be skipped if `SYCL_EXT_ONEAPI_DEVICE_GLOBAL` is not defined.

=== Tests for property_value

Get prop_values from prop_lists:

`property_list props1{device_image_scope};`

`auto prop_value1 = props.get_property<device_image_scope_key>();`

`property_list props2{host_access<A>};`
where `A = host_access_enum::read, host_access_enum::write, host_access_enum::read_write, host_access_enum::none`

`auto prop_value_A = props.get_property<host_access_key>();`

Check that for `prop_value1` members `value` and `value_t` are not available.

Check that for every `A` `prop_value_A` member `value` is `A` and member `value_t` is `host_access_enum`.

=== Tests for equality and inequality operators for properties

Get prop_values from prop_lists:

`property_list props1{device_image_scope};`

`auto prop_value_device_image_scope = props.get_property<device_image_scope_key>();`

`property_list props2{host_access<host_access_enum::read>};`

`auto prop_value_host_access_read = props2.get_property<host_access_key>();`

`property_list props3{host_access<host_access_enum::write>};`

`auto prop_value_host_access_write = props3.get_property<host_access_key>();`

Check constexpr correctness if required and result for operators:

[%header,cols="3,2,2,1"]
|===
|operator
|first parameter
|second parameter
|result

|`template <class Prop, class...A, class...B>
constexpr bool operator==(property_value<Prop, A...> V1, property_value<Prop, B...> V2)`
|`prop_value_device_image_scope`
|`prop_value_device_image_scope`
| `true`

|`template <class Prop, class...A, class...B>
constexpr bool operator!=(property_value<Prop, A...> V1, property_value<Prop, B...> V2)`
|`prop_value_device_image_scope`
|`prop_value_device_image_scope`
| `false`

|`template <class Prop, class...A, class...B>
constexpr bool operator==(property_value<Prop, A...> V1, property_value<Prop, B...> V2)`
|`prop_value_host_access_read`
|`prop_value_host_access_read`
| `true`

|`template <class Prop, class...A, class...B>
constexpr bool operator!=(property_value<Prop, A...> V1, property_value<Prop, B...> V2)`
|`prop_value_host_access_read`
|`prop_value_host_access_read`
| `false`

|`template <class Prop, class...A, class...B>
constexpr bool operator==(property_value<Prop, A...> V1, property_value<Prop, B...> V2)`
|`prop_value_host_access_read`
|`prop_value_host_access_write`
| `false`

|`template <class Prop, class...A, class...B>
constexpr bool operator!=(property_value<Prop, A...> V1, property_value<Prop, B...> V2)`
|`prop_value_host_access_read`
|`prop_value_host_access_write`
| `true`

|===

=== Tests for property_list

==== has_property

Create property_list with `property_list P1{device_image_scope}`
and check P1.has_property<T> returns:

* `true` for `T = device_image_scope_key`
* `false` for `T = host_access_key`

=== Tests for is_property_list

* Create property_list with `property_list props{device_image_scope, host_access<host_access_enum::read_write>}`
* Check that `is_property_list<decltype(props)>` is `std::true_type`
* Check that `is_property_list_v<decltype(props)>` is `true`

* Create custom class A
* Check that `is_property_list<A>` is `std::false_type`
* Check that `is_property_list_v<A>` is `false`

=== Different order

* Call property_list constructor `property_list P1{host_access<host_access_enum::read_write>, device_image_scope}`
* Call property_list constructor `property_list P2{device_image_scope, host_access<host_access_enum::read_write>}`
* Check that `std::is_same_v<decltype(P1), decltype(P2)>` is `true`.

=== is_property

* Check that `is_property<device_image_scope>` is `std::true_type`
* Check that `is_property<host_access>` is `std::true_type`

=== is_device_copyable

==== is_device_copyable for compile-time-constant properties

* Check that `is_device_copyable<device_image_scope::value_t>` is `std::true_type`
* Check that `is_device_copyable<host_access::value_t<host_access_enum::read>>` is `std::true_type`
* Check that `is_device_copyable<host_access::value_t<host_access_enum::write>>` is `std::true_type`
* Check that `is_device_copyable<host_access::value_t<host_access_enum::read_write>>` is `std::true_type`
* Check that `is_device_copyable<host_access::value_t<host_access_enum::none>>` is `std::true_type`

==== is_device_copyable for empty property_list

* Create empty propery_list `property_list P1{}`
* Check that `is_device_copyable<decltype(P1)>` is `std::true_type`

==== is_device_copyable for property_list with only compile-time-constant properties

* Create property_list `property_list P2{host_access<host_access_enum::read_write>, device_image_scope}`
* Check that `is_device_copyable<decltype(P2)>` is `std::true_type`
